================================================================================
СНИМОК ПРОЕКТА
Дата создания: 2025-08-23 05:57:52
Директория: /Users/eugene/Documents/go-metrics-and-alerts
Git ветка: main
Git коммит: ab9038352bcedd79562a2baf447296399d2b0402
================================================================================

СТРУКТУРА ПРОЕКТА
================================================================================

.
├── .github
│   └── workflows
│       ├── mertricstest.yml
│       └── statictest.yml
├── api
│   └── README.md
├── cmd
│   ├── agent
│   │   ├── main.go
│   │   └── README.md
│   ├── server
│   │   ├── main.go
│   │   └── README.md
│   └── README.md
├── internal
│   ├── agent
│   │   ├── agent.go
│   │   ├── config.go
│   │   └── README.md
│   ├── config
│   │   ├── db
│   │   │   └── README.md
│   │   └── README.md
│   ├── handler
│   │   ├── metrics_test.go
│   │   ├── metrics.go
│   │   └── README.md
│   ├── middleware
│   │   ├── gzip.go
│   │   └── logging.go
│   ├── model
│   │   ├── metrics.go
│   │   └── README.md
│   ├── repository
│   │   ├── interface.go
│   │   ├── memstorage_test.go
│   │   ├── memstorage.go
│   │   └── README.md
│   ├── service
│   │   └── README.md
│   └── README.md
├── migrations
│   └── README.md
├── pkg
│   └── README.md
├── .gitignore
├── go.mod
├── go.sum
├── project_collector.sh
├── project_snapshot.txt
└── README.md

18 directories, 34 files

================================================================================


================================================================================
СОДЕРЖИМОЕ ФАЙЛОВ
================================================================================

================================================================================
FILE: .github/workflows/mertricstest.yml
================================================================================

name: autotests

on:
  pull_request:
  push:
    branches:
      - main

jobs:

  branchtest:
    runs-on: ubuntu-latest

    steps:
      - name: Check branch name
        run: |
          if [[ ! $GITHUB_HEAD_REF =~ ^iter[0-9]+$ ]] && [[ ${{ github.ref }} != "refs/heads/main" ]]; then echo "Branch name must match pattern 'iter<number>' or github.ref must be 'refs/heads/main'" && echo "Your branch is $GITHUB_HEAD_REF and github.ref is ${{ github.ref }}" && exit 1; else echo "Your branch is $GITHUB_HEAD_REF and github.ref is ${{ github.ref }}"; fi

  metricstest:
    runs-on: ubuntu-latest
    container: golang:1.24
    needs: branchtest

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: praktikum
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Download autotests binaries
        uses: robinraju/release-downloader@v1.8
        with:
          repository: Yandex-Practicum/go-autotests
          latest: true
          fileName: "*"
          out-file-path: .tools
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup autotest binary
        run: |
          chmod -R +x $GITHUB_WORKSPACE/.tools
          mv $GITHUB_WORKSPACE/.tools/metricstest /usr/local/bin/metricstest
          mv $GITHUB_WORKSPACE/.tools/random /usr/local/bin/random

      - name: Setup go deps
        run: |
          go install golang.org/x/tools/cmd/goimports@latest


      - name: Build server binary
        run: |
          cd cmd/server
          go build -buildvcs=false -o server

      - name: "Code increment #1"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter1' ||
          github.head_ref == 'iter2' ||
          github.head_ref == 'iter3' ||
          github.head_ref == 'iter4' ||
          github.head_ref == 'iter5' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          metricstest -test.v -test.run=^TestIteration1$ \
            -binary-path=cmd/server/server

      - name: Build agent binary
        run: |
          cd cmd/agent
          go build -buildvcs=false  -o agent

      - name: "Code increment #2"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter2' ||
          github.head_ref == 'iter3' ||
          github.head_ref == 'iter4' ||
          github.head_ref == 'iter5' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          metricstest -test.v -test.run=^TestIteration2[AB]*$ \
            -source-path=. \
            -agent-binary-path=cmd/agent/agent

      - name: "Code increment #3"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter3' ||
          github.head_ref == 'iter4' ||
          github.head_ref == 'iter5' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          metricstest -test.v -test.run=^TestIteration3[AB]*$ \
            -source-path=. \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server

      - name: "Code increment #4"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter4' ||
          github.head_ref == 'iter5' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration4$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #5"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter5' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration5$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #6"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter6' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration6$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #7"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter7' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration7$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #8"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter8' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration8$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #9"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter9' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration9$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -file-storage-path=$TEMP_FILE \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #10"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter10' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration10[AB]$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -database-dsn='postgres://postgres:postgres@postgres:5432/praktikum?sslmode=disable' \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #11"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter11' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration11$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -database-dsn='postgres://postgres:postgres@postgres:5432/praktikum?sslmode=disable' \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #12"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter12' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration12$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -database-dsn='postgres://postgres:postgres@postgres:5432/praktikum?sslmode=disable' \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #13"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter13' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration13$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -database-dsn='postgres://postgres:postgres@postgres:5432/praktikum?sslmode=disable' \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #14"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter14'
        run: |
          SERVER_PORT=$(random unused-port)
          ADDRESS="localhost:${SERVER_PORT}"
          TEMP_FILE=$(random tempfile)
          metricstest -test.v -test.run=^TestIteration14$ \
            -agent-binary-path=cmd/agent/agent \
            -binary-path=cmd/server/server \
            -database-dsn='postgres://postgres:postgres@postgres:5432/praktikum?sslmode=disable' \
            -key="${TEMP_FILE}" \
            -server-port=$SERVER_PORT \
            -source-path=.

      - name: "Code increment #14 (race detection)"
        if: |
          github.ref == 'refs/heads/main' ||
          github.head_ref == 'iter14'
        run: |
          go test -v -race ./...


================================================================================
FILE: .github/workflows/statictest.yml
================================================================================

name: go vet test

on:
  pull_request:
  push:
    branches:
      - main

jobs:
  statictest:
    runs-on: ubuntu-latest
    container: golang:1.24
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Download statictest binary
        uses: robinraju/release-downloader@v1.8
        with:
          repository: Yandex-Practicum/go-autotests
          latest: true
          fileName: statictest
          out-file-path: .tools
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup autotest binary
        run: |
          chmod -R +x $GITHUB_WORKSPACE/.tools/statictest
          mv $GITHUB_WORKSPACE/.tools/statictest /usr/local/bin/statictest

      - name: Run statictest
        run: |
          go vet -vettool=$(which statictest) ./...


================================================================================
FILE: .gitignore
================================================================================

# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Binaries
cmd/agent/main
cmd/agent/agent
cmd/server/main
cmd/server/server

# Dependency directories (remove the comment below to include it)
vendor/

# IDEs directories
.idea
.vscode


================================================================================
FILE: api/README.md
================================================================================

# api

В этой директории принято размещать proto-файлы или файлы в формате OpenAPI/Swagger для описания контракта сервиса.

Protocol Buffers (Protobuf) будет изучаться дальше по курсу.

================================================================================
FILE: cmd/agent/main.go
================================================================================

package main

import (
	"log"

	"go-metrics-and-alerts/internal/agent"
)

func main() {
	cfg := agent.ParseConfig()
	a := agent.New(cfg)

	if err := a.Run(); err != nil {
		log.Fatal("Agent failed:", err)
	}
}


================================================================================
FILE: cmd/agent/README.md
================================================================================

# cmd/agent

В данной директории будет содержаться код Агента, который скомпилируется в бинарное приложение


================================================================================
FILE: cmd/README.md
================================================================================

# cmd

В данной директории содержится код, который скомпилируется в бинарное приложение.

Рекомендуется помещать только код, необходимый для запуска приложения, но не бизнес-логику.

Название директории должно соответствовать названию приложения.

Директория `cmd/app_name` содержит:
- точку входа в приложение (функция `main`)
- инициализацию зависимостей (можно вынести в отдельный пакет `internal/app`)
- настройку и запуск HTTP-сервера (можно вынести в отдельный пакет `internal/router`)
- обработку сигналов завершения работы приложения

================================================================================
FILE: cmd/server/main.go
================================================================================

package main

import (
	"encoding/json"
	"flag"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"go-metrics-and-alerts/internal/handler"
	"go-metrics-and-alerts/internal/middleware"
	models "go-metrics-and-alerts/internal/model"
	"go-metrics-and-alerts/internal/repository"

	"github.com/go-chi/chi/v5"
)

var (
	storage         repository.Repository
	fileStoragePath string
	storeInterval   int
)

func saveToFile() error {
	var metrics []models.Metrics

	gauges := storage.GetAllGauges()
	for name, value := range gauges {
		metric := models.Metrics{
			ID:    name,
			MType: "gauge",
			Value: &value,
		}
		metrics = append(metrics, metric)
	}

	counters := storage.GetAllCounters()
	for name, delta := range counters {
		metric := models.Metrics{
			ID:    name,
			MType: "counter",
			Delta: &delta,
		}
		metrics = append(metrics, metric)
	}

	data, err := json.Marshal(metrics)
	if err != nil {
		return err
	}

	return os.WriteFile(fileStoragePath, data, 0666)
}

func loadFromFile() error {
	data, err := os.ReadFile(fileStoragePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}

	var metrics []models.Metrics
	if err := json.Unmarshal(data, &metrics); err != nil {
		return err
	}

	for _, metric := range metrics {
		switch metric.MType {
		case "gauge":
			if metric.Value != nil {
				storage.UpdateGauge(metric.ID, *metric.Value)
			}
		case "counter":
			if metric.Delta != nil {
				storage.UpdateCounter(metric.ID, *metric.Delta)
			}
		}
	}

	return nil
}

func main() {
	addr := flag.String("a", "localhost:8080", "server address")
	storeIntervalFlag := flag.Int("i", 300, "store interval in seconds")
	fileStoragePathFlag := flag.String("f", "/tmp/metrics-db.json", "file storage path")
	restore := flag.Bool("r", true, "restore from file")
	flag.Parse()

	finalAddr := *addr
	if envAddr := os.Getenv("ADDRESS"); envAddr != "" {
		finalAddr = envAddr
	}

	storeInterval = *storeIntervalFlag
	if envInterval := os.Getenv("STORE_INTERVAL"); envInterval != "" {
		if val, err := strconv.Atoi(envInterval); err == nil {
			storeInterval = val
		}
	}

	fileStoragePath = *fileStoragePathFlag
	if envPath := os.Getenv("FILE_STORAGE_PATH"); envPath != "" {
		fileStoragePath = envPath
	}

	finalRestore := *restore
	if envRestore := os.Getenv("RESTORE"); envRestore != "" {
		if val, err := strconv.ParseBool(envRestore); err == nil {
			finalRestore = val
		}
	}

	storage = repository.NewMemStorage()

	if finalRestore {
		if err := loadFromFile(); err != nil {
			log.Printf("Failed to load from file: %v", err)
		}
	}

	defer func() {
		if err := saveToFile(); err != nil {
			log.Printf("Failed to save to file: %v", err)
		}
	}()

	if storeInterval > 0 {
		go func() {
			ticker := time.NewTicker(time.Duration(storeInterval) * time.Second)
			defer ticker.Stop()
			for range ticker.C {
				if err := saveToFile(); err != nil {
					log.Printf("Failed to save to file: %v", err)
				}
			}
		}()
	}

	h := handler.New(storage)

	if storeInterval == 0 {
		handler.SyncSaveFunc = func() {
			if err := saveToFile(); err != nil {
				log.Printf("Failed to sync save: %v", err)
			}
		}
	}

	r := chi.NewRouter()

	r.Use(middleware.WithLogging)
	r.Use(middleware.WithGzipDecompress)
	r.Use(middleware.WithGzip)

	r.Post("/update/{type}/{name}/{value}", h.UpdateMetric)
	r.Post("/update", h.UpdateMetricJSON)
	r.Post("/update/", h.UpdateMetricJSON)
	r.Get("/value/{type}/{name}", h.GetMetric)
	r.Post("/value", h.GetMetricJSON)
	r.Post("/value/", h.GetMetricJSON)
	r.Get("/", h.ListMetrics)

	log.Printf("Starting server on %s", finalAddr)
	if err := http.ListenAndServe(finalAddr, r); err != nil {
		log.Fatal("Server fail:", err)
	}
}


================================================================================
FILE: cmd/server/README.md
================================================================================

# cmd/server

В данной директории будет содержаться код Сервера, который скомпилируется в бинарное приложение


================================================================================
FILE: go.mod
================================================================================

module go-metrics-and-alerts

go 1.24.3

require (
	github.com/go-chi/chi/v5 v5.2.1
	go.uber.org/zap v1.27.0
)

require go.uber.org/multierr v1.10.0 // indirect


================================================================================
FILE: go.sum
================================================================================

github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-chi/chi/v5 v5.2.1 h1:KOIHODQj58PmL80G2Eak4WdvUzjSJSm0vG72crDCqb8=
github.com/go-chi/chi/v5 v5.2.1/go.mod h1:L2yAIGWB3H+phAw1NxKwWM+7eUH/lU8pOMm5hHcoops=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=
go.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


================================================================================
FILE: internal/agent/agent.go
================================================================================

package agent

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"runtime"
	"time"

	models "go-metrics-and-alerts/internal/model"
)

type Agent struct {
	config      *Config
	randomValue float64
	client      *http.Client
}

func New(config *Config) *Agent {
	return &Agent{
		config: config,
		client: &http.Client{},
	}
}

func (a *Agent) Run() error {
	pollTicker := time.NewTicker(a.config.PollInterval)
	reportTicker := time.NewTicker(a.config.ReportInterval)

	metrics := make(map[string]interface{})
	pollsSinceLastReport := int64(0)

	log.Printf("Agent starting, server: %s, poll: %v, report: %v",
		a.config.ServerURL, a.config.PollInterval, a.config.ReportInterval)

	for {
		select {
		case <-pollTicker.C:
			a.collectMetrics(metrics)
			pollsSinceLastReport++
			log.Printf("Collected metrics, polls since last report: %d", pollsSinceLastReport)

		case <-reportTicker.C:
			metrics["PollCount"] = pollsSinceLastReport
			log.Printf("Sending %d metrics", len(metrics))
			a.sendMetrics(metrics)
			pollsSinceLastReport = 0
		}
	}
}

func (a *Agent) collectMetrics(metrics map[string]interface{}) {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	metrics["Alloc"] = float64(m.Alloc)
	metrics["BuckHashSys"] = float64(m.BuckHashSys)
	metrics["Frees"] = float64(m.Frees)
	metrics["GCCPUFraction"] = m.GCCPUFraction
	metrics["GCSys"] = float64(m.GCSys)
	metrics["HeapAlloc"] = float64(m.HeapAlloc)
	metrics["HeapIdle"] = float64(m.HeapIdle)
	metrics["HeapInuse"] = float64(m.HeapInuse)
	metrics["HeapObjects"] = float64(m.HeapObjects)
	metrics["HeapReleased"] = float64(m.HeapReleased)
	metrics["HeapSys"] = float64(m.HeapSys)
	metrics["LastGC"] = float64(m.LastGC)
	metrics["Lookups"] = float64(m.Lookups)
	metrics["MCacheInuse"] = float64(m.MCacheInuse)
	metrics["MCacheSys"] = float64(m.MCacheSys)
	metrics["MSpanInuse"] = float64(m.MSpanInuse)
	metrics["MSpanSys"] = float64(m.MSpanSys)
	metrics["Mallocs"] = float64(m.Mallocs)
	metrics["NextGC"] = float64(m.NextGC)
	metrics["NumForcedGC"] = float64(m.NumForcedGC)
	metrics["NumGC"] = float64(m.NumGC)
	metrics["OtherSys"] = float64(m.OtherSys)
	metrics["PauseTotalNs"] = float64(m.PauseTotalNs)
	metrics["StackInuse"] = float64(m.StackInuse)
	metrics["StackSys"] = float64(m.StackSys)
	metrics["Sys"] = float64(m.Sys)
	metrics["TotalAlloc"] = float64(m.TotalAlloc)

	a.randomValue = rand.Float64()
	metrics["RandomValue"] = a.randomValue
}

func (a *Agent) sendMetrics(metrics map[string]interface{}) {
	sent := 0
	for name, value := range metrics {
		if err := a.sendSingleMetric(name, value); err != nil {
			log.Printf("Err sending metric: %v", err)
			continue
		}
		sent++
	}
	log.Printf("Sent %d metrics", sent)
}

func (a *Agent) sendSingleMetric(name string, value interface{}) error {
	var metric models.Metrics
	metric.ID = name

	switch v := value.(type) {
	case float64:
		metric.MType = "gauge"
		metric.Value = &v
	case int64:
		metric.MType = "counter"
		metric.Delta = &v
	default:
		return fmt.Errorf("unsupported type for %s", name)
	}

	jsonData, err := json.Marshal(metric)
	if err != nil {
		return fmt.Errorf("marshaling metric %s: %w", name, err)
	}

	var buf bytes.Buffer
	gz := gzip.NewWriter(&buf)
	if _, err := gz.Write(jsonData); err != nil {
		return fmt.Errorf("gzip write error for %s: %w", name, err)
	}
	if err := gz.Close(); err != nil {
		return fmt.Errorf("gzip close error for %s: %w", name, err)
	}

	url := fmt.Sprintf("%s/update", a.config.ServerURL)
	req, err := http.NewRequest("POST", url, &buf)
	if err != nil {
		return fmt.Errorf("creating request for %s: %w", name, err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Content-Encoding", "gzip")
	req.Header.Set("Accept-Encoding", "gzip")

	resp, err := a.client.Do(req)
	if err != nil {
		return fmt.Errorf("sending metric %s: %w", name, err)
	}
	resp.Body.Close()

	return nil
}


================================================================================
FILE: internal/agent/config.go
================================================================================

package agent

import (
	"flag"
	"os"
	"strconv"
	"time"
)

type Config struct {
	ServerURL      string
	PollInterval   time.Duration
	ReportInterval time.Duration
}

func ParseConfig() *Config {
	addr := flag.String("a", "localhost:8080", "server address")
	reportInterval := flag.Int("r", 10, "report interval in seconds")
	pollInterval := flag.Int("p", 2, "poll interval in seconds")
	flag.Parse()
	
	finalAddr := *addr
	if envAddr := os.Getenv("ADDRESS"); envAddr != "" {
		finalAddr = envAddr
	}

	finalReportInterval := *reportInterval
	if envReport := os.Getenv("REPORT_INTERVAL"); envReport != "" {
		if val, err := strconv.Atoi(envReport); err == nil {
			finalReportInterval = val
		}
	}

	finalPollInterval := *pollInterval
	if envPoll := os.Getenv("POLL_INTERVAL"); envPoll != "" {
		if val, err := strconv.Atoi(envPoll); err == nil {
			finalPollInterval = val
		}
	}

	return &Config{
		ServerURL:      "http://" + finalAddr,
		PollInterval:   time.Duration(finalPollInterval) * time.Second,
		ReportInterval: time.Duration(finalReportInterval) * time.Second,
	}
}

================================================================================
FILE: internal/agent/README.md
================================================================================

# internal/agent

В данной директории будет содержаться имплементация вашего сервиса

================================================================================
FILE: internal/config/db/README.md
================================================================================

# internal/config/db

Описание конфигурации подключения к базе данных.

Этот пакет содержит:
- структуры конфигурации для подключения к БД
- параметры соединения и пула подключений
- настройки для различных типов баз данных
- логику инициализации подключения

================================================================================
FILE: internal/config/README.md
================================================================================

# internal/config

В этом пакете хранятся конфигурации приложения.

Загрузку конфигурации можно реализовать из различных источников, например, из файла, из переменных окружения, из БД и т.д.

================================================================================
FILE: internal/handler/metrics_test.go
================================================================================

package handler

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"go-metrics-and-alerts/internal/repository"

	"github.com/go-chi/chi/v5"
)

func TestUpdateMetric(t *testing.T) {
	storage := repository.NewMemStorage()
	handler := New(storage)

	r := chi.NewRouter()
	r.Post("/update/{type}/{name}/{value}", handler.UpdateMetric)

	tests := []struct {
		path   string
		status int
	}{
		{"/update/gauge/test/123.45", http.StatusOK},
		{"/update/counter/test/123", http.StatusOK},
		{"/update/bad/test/123", http.StatusBadRequest},
	}

	for _, test := range tests {
		req := httptest.NewRequest("POST", test.path, nil)
		w := httptest.NewRecorder()

		r.ServeHTTP(w, req)

		if w.Code != test.status {
			t.Fatalf("Expected %d, got %d for %s", test.status, w.Code, test.path)
		}
	}
}

func TestGetMetric(t *testing.T) {
	storage := repository.NewMemStorage()
	handler := New(storage)

	storage.UpdateGauge("test", 123.45)
	storage.UpdateCounter("counter", 100)

	r := chi.NewRouter()
	r.Get("/value/{type}/{name}", handler.GetMetric)

	tests := []struct {
		path   string
		status int
		body   string
	}{
		{"/value/gauge/test", http.StatusOK, "123.45"},
		{"/value/counter/counter", http.StatusOK, "100"},
		{"/value/gauge/missing", http.StatusNotFound, ""},
	}

	for _, test := range tests {
		req := httptest.NewRequest("GET", test.path, nil)
		w := httptest.NewRecorder()

		r.ServeHTTP(w, req)

		if w.Code != test.status {
			t.Fatalf("Expected %d, got %d for %s", test.status, w.Code, test.path)
		}

		if test.body != "" && !strings.Contains(w.Body.String(), test.body) {
			t.Fatalf("Expected body to contain %s, got %s", test.body, w.Body.String())
		}
	}
}


================================================================================
FILE: internal/handler/metrics.go
================================================================================

package handler

import (
	"encoding/json"
	"html/template"
	"log"
	"net/http"
	"strconv"

	models "go-metrics-and-alerts/internal/model"
	"go-metrics-and-alerts/internal/repository"

	"github.com/go-chi/chi/v5"
)

var SyncSaveFunc func()

type Handler struct {
	storage repository.Repository
}

func New(storage repository.Repository) *Handler {
	return &Handler{storage: storage}
}

func (h *Handler) UpdateMetric(w http.ResponseWriter, r *http.Request) {
	metricType := chi.URLParam(r, "type")
	metricName := chi.URLParam(r, "name")
	metricValue := chi.URLParam(r, "value")

	if metricName == "" {
		http.Error(w, "Not found", http.StatusNotFound)
		return
	}

	switch metricType {
	case "gauge":
		value, err := strconv.ParseFloat(metricValue, 64)
		if err != nil {
			http.Error(w, "Bad request", http.StatusBadRequest)
			return
		}
		if err := h.storage.UpdateGauge(metricName, value); err != nil {
			log.Printf("Error updating gauge: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}

	case "counter":
		value, err := strconv.ParseInt(metricValue, 10, 64)
		if err != nil {
			http.Error(w, "Bad request", http.StatusBadRequest)
			return
		}
		if err := h.storage.UpdateCounter(metricName, value); err != nil {
			log.Printf("Error updating counter: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}

	default:
		http.Error(w, "Bad request", http.StatusBadRequest)
		return
	}

	if SyncSaveFunc != nil {
		SyncSaveFunc()
	}

	w.WriteHeader(http.StatusOK)
}

func (h *Handler) GetMetric(w http.ResponseWriter, r *http.Request) {
	metricType := chi.URLParam(r, "type")
	metricName := chi.URLParam(r, "name")

	switch metricType {
	case "gauge":
		value, exists := h.storage.GetGauge(metricName)
		if !exists {
			http.Error(w, "Not found", http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "text/plain")
		if _, err := w.Write([]byte(strconv.FormatFloat(value, 'g', -1, 64))); err != nil {
			log.Printf("Error writing response: %v", err)
		}

	case "counter":
		value, exists := h.storage.GetCounter(metricName)
		if !exists {
			http.Error(w, "Not found", http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "text/plain")
		if _, err := w.Write([]byte(strconv.FormatInt(value, 10))); err != nil {
			log.Printf("Error writingg response: %v", err)
		}

	default:
		http.Error(w, "Bad request", http.StatusBadRequest)
	}
}

func (h *Handler) ListMetrics(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html")

	tmpl := `<html><body><h1>Metrics</h1>
<h2>Gauges</h2><ul>
{{range $name, $value := .Gauges}}
<li>{{$name}}: {{$value}}</li>
{{end}}
</ul>
<h2>Counters</h2><ul>
{{range $name, $value := .Counters}}
<li>{{$name}}: {{$value}}</li>
{{end}}
</ul>
</body></html>`

	t, err := template.New("metrics").Parse(tmpl)
	if err != nil {
		log.Printf("Error parsing template: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	data := struct {
		Gauges   map[string]float64
		Counters map[string]int64
	}{
		Gauges:   h.storage.GetAllGauges(),
		Counters: h.storage.GetAllCounters(),
	}

	if err := t.Execute(w, data); err != nil {
		log.Printf("Error executing template: %v", err)
	}
}

func (h *Handler) UpdateMetricJSON(w http.ResponseWriter, r *http.Request) {
	var metric models.Metrics

	if err := json.NewDecoder(r.Body).Decode(&metric); err != nil {
		http.Error(w, "Bad request", http.StatusBadRequest)
		return
	}

	switch metric.MType {
	case "gauge":
		if metric.Value == nil {
			http.Error(w, "Bad request", http.StatusBadRequest)
			return
		}
		if err := h.storage.UpdateGauge(metric.ID, *metric.Value); err != nil {
			log.Printf("Error updating gauge: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}

	case "counter":
		if metric.Delta == nil {
			http.Error(w, "Bad request", http.StatusBadRequest)
			return
		}
		if err := h.storage.UpdateCounter(metric.ID, *metric.Delta); err != nil {
			log.Printf("Error updating counter: %v", err)
			http.Error(w, "Internal server error", http.StatusInternalServerError)
			return
		}

	default:
		http.Error(w, "Bad request", http.StatusBadRequest)
		return
	}

	if SyncSaveFunc != nil {
		SyncSaveFunc()
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(metric)
	if err != nil {
		log.Printf("Error marshaling response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(resp)
}

func (h *Handler) GetMetricJSON(w http.ResponseWriter, r *http.Request) {
	var metric models.Metrics

	if err := json.NewDecoder(r.Body).Decode(&metric); err != nil {
		http.Error(w, "Bad request", http.StatusBadRequest)
		return
	}

	switch metric.MType {
	case "gauge":
		value, exists := h.storage.GetGauge(metric.ID)
		if !exists {
			http.Error(w, "Not found", http.StatusNotFound)
			return
		}
		metric.Value = &value

	case "counter":
		value, exists := h.storage.GetCounter(metric.ID)
		if !exists {
			http.Error(w, "Not found", http.StatusNotFound)
			return
		}
		metric.Delta = &value

	default:
		http.Error(w, "Bad request", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(metric)
	if err != nil {
		log.Printf("Error marshaling response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(resp)
}


================================================================================
FILE: internal/handler/README.md
================================================================================

# internal/handler

В этом пакете размещаются обработчики HTTP-запросов. Здесь инкапсулируется так называемая логика представления.

Обычно хэндлеры реализуют:
- логику обработки запросов
- валидацию данных
- вызовы сервисов, в которых содержится бизнес-логика приложения
- формирование HTTP-ответов

Рекомендуется разбивать хэндлеры по функциональным группам и следовать принципу, где хэндлеры являются адаптерами между HTTP-транспортом и бизнес-логикой приложения.

================================================================================
FILE: internal/middleware/gzip.go
================================================================================

package middleware

import (
	"compress/gzip"
	"io"
	"net/http"
	"strings"
)

type gzipWriter struct {
	http.ResponseWriter
	Writer         io.Writer
	gzipWriter     *gzip.Writer
	wroteHeader    bool
	shouldCompress bool
}

func (w *gzipWriter) WriteHeader(statusCode int) {
	if w.wroteHeader {
		return
	}
	w.wroteHeader = true

	contentType := w.Header().Get("Content-Type")
	w.shouldCompress = strings.Contains(contentType, "application/json") ||
		strings.Contains(contentType, "text/html")

	if w.shouldCompress {
		w.Header().Set("Content-Encoding", "gzip")
	}

	w.ResponseWriter.WriteHeader(statusCode)
}

func (w *gzipWriter) Write(b []byte) (int, error) {
	if !w.wroteHeader {
		w.WriteHeader(200)
	}

	if w.shouldCompress {
		return w.Writer.Write(b)
	}
	return w.ResponseWriter.Write(b)
}

func WithGzip(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !strings.Contains(r.Header.Get("Accept-Encoding"), "gzip") {
			next.ServeHTTP(w, r)
			return
		}

		gz, err := gzip.NewWriterLevel(w, gzip.BestSpeed)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		defer gz.Close()

		next.ServeHTTP(&gzipWriter{
			ResponseWriter: w,
			Writer:         gz,
			gzipWriter:     gz,
		}, r)
	})
}

func WithGzipDecompress(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Header.Get("Content-Encoding") == "gzip" {
			gz, err := gzip.NewReader(r.Body)
			if err != nil {
				http.Error(w, "Bad request", http.StatusBadRequest)
				return
			}
			defer gz.Close()
			r.Body = gz
		}
		next.ServeHTTP(w, r)
	})
}


================================================================================
FILE: internal/middleware/logging.go
================================================================================

package middleware

import (
	"net/http"
	"time"

	"go.uber.org/zap"
)

var sugar zap.SugaredLogger

func init() {
	logger, err := zap.NewDevelopment()
	if err != nil {
		panic(err)
	}
	defer logger.Sync()

	sugar = *logger.Sugar()
}

type (
	responseData struct {
		status int
		size   int
	}

	loggingResponseWriter struct {
		http.ResponseWriter
		responseData *responseData
	}
)

func (r *loggingResponseWriter) Write(b []byte) (int, error) {
	size, err := r.ResponseWriter.Write(b)
	r.responseData.size += size
	return size, err
}

func (r *loggingResponseWriter) WriteHeader(statusCode int) {
	r.ResponseWriter.WriteHeader(statusCode)
	r.responseData.status = statusCode
}

func WithLogging(h http.Handler) http.Handler {
	logFn := func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		responseData := &responseData{
			status: 200,
			size:   0,
		}
		lw := loggingResponseWriter{
			ResponseWriter: w,
			responseData:   responseData,
		}
		h.ServeHTTP(&lw, r)

		duration := time.Since(start)

		sugar.Infoln(
			"uri", r.RequestURI,
			"method", r.Method,
			"status", responseData.status,
			"duration", duration,
			"size", responseData.size,
		)
	}
	return http.HandlerFunc(logFn)
}


================================================================================
FILE: internal/model/metrics.go
================================================================================

package models

const (
	Counter = "counter"
	Gauge   = "gauge"
)

// NOTE: Не усложняем пример, вводя иерархическую вложенность структур.
// Органичиваясь плоской моделью.
// Delta и Value объявлены через указатели,
// что бы отличать значение "0", от не заданного значения
// и соответственно не кодировать в структуру.
type Metrics struct {
	ID    string   `json:"id"`
	MType string   `json:"type"`
	Delta *int64   `json:"delta,omitempty"`
	Value *float64 `json:"value,omitempty"`
	Hash  string   `json:"hash,omitempty"`
}


================================================================================
FILE: internal/model/README.md
================================================================================

# internal/model

В этом пакете размещаются структуры данных, которые представляют основные сущности предметной области приложения.

Эти структуры используются в сервисах и хэндлерах. Данный пакет не должен содержать бизнес-логику приложения.

================================================================================
FILE: internal/README.md
================================================================================

# internal

В этой директории размещается код внутренних модулей приложения. Код внутри этого пакета не доступен для импорта в других приложениях.

Структуру дирктории `internal/` можно разбивать по логическим блокам приложения, выделяя пакеты по функциональному назначению. 
Например, `internal/agent`, `internal/server` и т.д.

Директория `internal/` является специальной в Go и обеспечивает инкапсуляцию кода на уровне модуля. Компилятор Go запрещает импорт пакетов из `internal/` за пределами родительского модуля.

================================================================================
FILE: internal/repository/interface.go
================================================================================

package repository

type Repository interface {
	UpdateGauge(name string, value float64) error
	UpdateCounter(name string, value int64) error
	GetGauge(name string) (float64, bool)
	GetCounter(name string) (int64, bool)
	GetAllGauges() map[string]float64
	GetAllCounters() map[string]int64
}


================================================================================
FILE: internal/repository/memstorage_test.go
================================================================================

package repository

import "testing"

func TestMemStorage(t *testing.T) {
	storage := NewMemStorage()

	storage.UpdateGauge("test", 123.45)
	value, exists := storage.GetGauge("test")
	if !exists || value != 123.45 {
		t.Errorf("Expected 123.45, got %f", value)
	}

	storage.UpdateCounter("counter", 10)
	storage.UpdateCounter("counter", 5)
	counter, exists := storage.GetCounter("counter")
	if !exists || counter != 15 {
		t.Errorf("Expected 15, got %d", counter)
	}
}


================================================================================
FILE: internal/repository/memstorage.go
================================================================================

package repository

import "sync"

type MemStorage struct {
	gauges   map[string]float64
	counters map[string]int64
	mu       *sync.Mutex
}

func NewMemStorage() *MemStorage {
	return &MemStorage{
		gauges:   make(map[string]float64),
		counters: make(map[string]int64),
		mu:       &sync.Mutex{},
	}
}

func (m *MemStorage) UpdateGauge(name string, value float64) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.gauges[name] = value
	return nil
}

func (m *MemStorage) UpdateCounter(name string, value int64) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.counters[name] += value
	return nil
}

func (m *MemStorage) GetGauge(name string) (float64, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	value, exists := m.gauges[name]
	return value, exists
}

func (m *MemStorage) GetCounter(name string) (int64, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	value, exists := m.counters[name]
	return value, exists
}

func (m *MemStorage) GetAllGauges() map[string]float64 {
	m.mu.Lock()
	defer m.mu.Unlock()
	result := make(map[string]float64)
	for k, v := range m.gauges {
		result[k] = v
	}
	return result
}

func (m *MemStorage) GetAllCounters() map[string]int64 {
	m.mu.Lock()
	defer m.mu.Unlock()
	result := make(map[string]int64)
	for k, v := range m.counters {
		result[k] = v
	}
	return result
}


================================================================================
FILE: internal/repository/README.md
================================================================================

# internal/repository

Это пакет, содержит реализацию работы с базой данных, а также с внешними сервисами.

Важно, чтобы в репозитории не содержалось бизнес-логики.

Репозиторий реализует паттерн Repository и служит абстракцией над различными источниками данных, такими как:
- базы данных (PostgreSQL, MySQL и др.)
- внешние API
- файловые системы
- кэши (Redis, Memcached)
- и другие

================================================================================
FILE: internal/service/README.md
================================================================================

# internal/service

Пакет service содержит бизнес-логику приложения и играет ключевую роль в реализации функциональности приложения.

Здесь реализуются правила, процессы и операции, которые определяют поведение приложения.

Принципы организации:
- Сервисы должны быть независимы от деталей транспорта (HTTP, gRPC и т.д.)
- Взаимодействие с базой данных происходит через интерфейсы репозиториев
- Каждый сервис должен иметь четко определенную область ответственности

================================================================================
FILE: migrations/README.md
================================================================================

# migrations

В данной директории содержаться файлы миграций базы данных.

Миграции базы данных — это скрипты, которые позволяют:
- версионировать изменения схемы базы данных
- применять изменения в правильном порядке
- откатывать изменения при необходимости

Тема миграций будет подробно изучаться дальше по курсу.

================================================================================
FILE: pkg/README.md
================================================================================

# pkg

В данной директории размещаются файлы, которые можно импортировать в других приложениях. 

Например, сюда можно поместить:
- сгенерированные контракты из proto-файлов
- публичные библиотеки и утилиты
- общие модели данных
- клиентские SDK

Protocol Buffers (Protobuf) будет изучаться дальше по курсу.

================================================================================
FILE: README.md
================================================================================

# go-musthave-metrics-tpl

Шаблон репозитория для трека «Сервер сбора метрик и алертинга».

## Начало работы

1. Склонируйте репозиторий в любую подходящую директорию на вашем компьютере.
2. В корне репозитория выполните команду `go mod init <name>` (где `<name>` — адрес вашего репозитория на GitHub без префикса `https://`) для создания модуля.

## Обновление шаблона

Чтобы иметь возможность получать обновления автотестов и других частей шаблона, выполните команду:

```
git remote add -m main template https://github.com/Yandex-Practicum/go-musthave-metrics-tpl.git
```

Для обновления кода автотестов выполните команду:

```
git fetch template && git checkout template/main .github
```

Затем добавьте полученные изменения в свой репозиторий.

## Запуск автотестов

Для успешного запуска автотестов называйте ветки `iter<number>`, где `<number>` — порядковый номер инкремента. Например, в ветке с названием `iter4` запустятся автотесты для инкрементов с первого по четвёртый.

При мёрже ветки с инкрементом в основную ветку `main` будут запускаться все автотесты.

Подробнее про локальный и автоматический запуск читайте в [README автотестов](https://github.com/Yandex-Practicum/go-autotests).

## Структура проекта

Приведенная в этом репозитории структура проекта является рекомендуемой, но не обязательной.

Это лишь пример организации кода, который поможет вам в реализации сервиса.

При необходимости можно вносить изменения в структуру проекта, использовать любые библиотеки и предпочитаемые структурные паттерны организации кода приложения, например:
- **DDD** (Domain-Driven Design)
- **Clean Architecture**
- **Hexagonal Architecture**
- **Layered Architecture**

================================================================================
КОНЕЦ СНИМКА ПРОЕКТА
Обработано файлов: 34
Дата завершения: 2025-08-23 05:57:53
================================================================================
